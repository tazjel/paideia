(dp1
S'output'
p2
S"<type 'exceptions.KeyError'> 'location'"
p3
sS'layer'
p4
S'/home/ian/web/web2py/applications/paideia/controllers/exploring.py'
p5
sS'code'
p6
S'# coding: utf8\nfrom paideia_exploring import paideia_path, paideia_tag, counter, map\nfrom paideia_questions import question\nimport pprint\n\ndef session_init():\n    print \'calling session_init\'\n    #categorize paths for today\n    tags = paideia_tag()\n    session.tagset = tags.categorize_tags()\n    print \'returned categorized tags\'\n    print \'session.tagset: \', pprint.pprint(session.tagset)\n    #add paths that weren\'t finished during last session\n    path = paideia_path()\n    session.active_paths = path.find_unfinished()\n    print \'returned unfinished paths\'\n    print \'session active_paths: \', session.active_paths\n\ndef step_init():\n    print \'calling step_init()\'\n    #find out what location has been entered\n    curr_loc = db(db.locations.alias == request.vars[\'loc\']).select().first()\n    print \'current location: \', curr_loc.alias, curr_loc.id\n\n    #check to see whether any constraints are in place \n    if \'blocks\' in session:\n        print \'active block conditions: \', session.blocks\n        #TODO: Add logic here to handle blocking conditions\n    else:\n        print \'no blocking conditions\'\n    \n    #find out what paths (if any) are currently active\n    a_paths = [1, 2]#session.active_path or None\n    print \'active paths: \', a_paths\n    \n    #if an active path has a step here, initiate that step\n    for a in a_paths:\n        pathsteps = db((db.paths.steps.contains(a))\n                       & (db.paths.location == curr_loc.id)).select()\n        \n    if pathsteps:\n        print \'continuing active path \', pathsteps\n    else:\n        print \'no active paths here\'\n    \n    #find paths with tags open to student\n    #look for tags with high priority\n    #if none look for tags with medium priority\n    #if none,  \n        return dict()\n\ndef stepask():\n    #check to see whether a path is active and determines the next step\n    if session.active_path:\n        pass\n    \n    #if not, initiate new path \n    if not request.vars.response:\n        set_path = paideia_path()\n        set_counter = counter()\n        the_question = question()\n        the_question.selectq()\n\n    form = SQLFORM.factory(\n        Field(\'response\', \'string\', requires=IS_NOT_EMPTY())\n    )\n    if form.accepts(request.vars,session):\n        session.response = request.vars.response\n        redirect(URL(\'index\', args=[\'reply\']))\n\n    return dict(question=session.question_text, form=form)\n\ndef stepreply():\n    #see whether answer matches any of the three answer fields\n    q = question()\n    the_eval = q.evalq()\n\n    #build response to user\n    if session.eval == \'correct\':\n        the_reply = "Right. \xce\x9a\xce\xac\xce\xbb\xce\xb7."\n    elif session.eval == \'partial\':\n        the_reply = "\xce\x9f\xe1\xbd\x90 \xce\xba\xce\xac\xce\xba\xce\xbf\xcf\x82. You\'re close."\n    else:\n        the_reply = "Incorrect. Try again!"\n\n    #add a record for this attempt in db.attempt_log\n    db.attempt_log.insert(question=session.q_ID, score=q.score, quiz=session.path_id)\n\n    return dict(reply=the_reply, answer=session.readable_answer, raw_answer=session.answer, score=session.score)\n\n\ndef patherror():\n    if request.args(1) == \'unknown\':\n        db.q_bugs.insert(question=session.qID, a_submitted=request.vars.answer)\n        #TODO: fix problem with changing column name for status\n        #db(db.questions.id==session.qID).update(qqq_status=1);\n    if request.args(1) == \'regex\':\n        db.q_bugs.insert(question=session.qID, a_submitted=request.vars.answer)\n        #db(db.questions.id==session.qID).update(qqq_status=1);\n    message = "Oops! Something about that question confused me, and I\'m not sure whether your answer was right. Let\'s try another one."\n    button = A(\'continue\', _href=URL(\'index\', args=[\'ask\']), _class=\'button-green-grad next_q\', cid=request.cid)\n    #don\'t include this question in counting the number attempted\n    session.q_counter -= 1\n    return dict(message = message, button = button)\n\n@auth.requires_login()\ndef index():\n    #check to see whether this user session has been initialized\n    if not session.tagset:\n        session_init()\n\n    #when user begins exploring (also default) present map\n    if (request.args(0) == \'start\') or (not request.args):\n        the_map = map()\n        for i in [\'blocks\', \'active_paths\', \'completed_paths\']:\n            if not session[i]:\n                print i\n                session[i] = None\n             \n        return dict(locs = the_map.locs, map_image = the_map.image)\n\n    #after user selects quiz (or \'next question\')\n    elif request.args(0) == \'ask\':\n        return step_init()\n\n    #after submitting answer\n    elif request.args(0) == \'reply\':\n        return stepreply()\n    \n    elif request.args(0) == \'error\':\n        return patherror()\n        \n    \nresponse._vars=response._caller(index)\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "/home/ian/web/web2py/gluon/restricted.py", line 204, in restricted\n    exec ccode in environment\n  File "/home/ian/web/web2py/applications/paideia/controllers/exploring.py", line 134, in <module>\n  File "/home/ian/web/web2py/gluon/globals.py", line 172, in <lambda>\n    self._caller = lambda f: f()\n  File "/home/ian/web/web2py/gluon/tools.py", line 2533, in f\n    return action(*a, **b)\n  File "/home/ian/web/web2py/applications/paideia/controllers/exploring.py", line 124, in index\n    return step_init()\n  File "/home/ian/web/web2py/applications/paideia/controllers/exploring.py", line 39, in step_init\n    & (db.paths.location == curr_loc.id)).select()\n  File "/home/ian/web/web2py/gluon/dal.py", line 5542, in __getattr__\n    return self[key]\n  File "/home/ian/web/web2py/gluon/dal.py", line 5482, in __getitem__\n    return dict.__getitem__(self, str(key))\nKeyError: \'location\'\n'
p11
s.
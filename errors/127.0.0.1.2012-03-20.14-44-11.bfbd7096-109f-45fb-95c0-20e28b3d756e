(dp1
S'output'
p2
S"<type 'exceptions.KeyError'> '_primarykey'"
p3
sS'layer'
p4
S'/home/iscott/web/web2py/applications/paideia/controllers/exploring.py'
p5
sS'code'
p6
S'# coding: utf8\nfrom paideia_exploring import path, tag, step, counter, map\nfrom paideia_questions import question\nimport pprint\n\ndef stepreply():\n    #see whether answer matches any of the three answer fields\n    q = question()\n    the_eval = q.evalq()\n\n    #build response to user\n    if session.eval == \'correct\':\n        the_reply = "Right. \xce\x9a\xce\xac\xce\xbb\xce\xb7."\n    elif session.eval == \'partial\':\n        the_reply = "\xce\x9f\xe1\xbd\x90 \xce\xba\xce\xac\xce\xba\xce\xbf\xcf\x82. You\'re close."\n    else:\n        the_reply = "Incorrect. Try again!"\n\n    #add a record for this attempt in db.attempt_log\n    db.attempt_log.insert(question=session.q_ID, score=q.score, quiz=session.path_id)\n\n    return dict(reply=the_reply, answer=session.readable_answer, raw_answer=session.answer, score=session.score)\n\ndef patherror():\n    if request.args(1) == \'unknown\':\n        db.q_bugs.insert(question=session.qID, a_submitted=request.vars.answer)\n        #TODO: fix problem with changing column name for status\n        #db(db.questions.id==session.qID).update(qqq_status=1);\n    if request.args(1) == \'regex\':\n        db.q_bugs.insert(question=session.qID, a_submitted=request.vars.answer)\n        #db(db.questions.id==session.qID).update(qqq_status=1);\n    message = "Oops! Something about that question confused me, and I\'m not sure whether your answer was right. Let\'s try another one."\n    button = A(\'continue\', _href=URL(\'index\', args=[\'ask\']), _class=\'button-green-grad next_q\', cid=request.cid)\n    #don\'t include this question in counting the number attempted\n    session.q_counter -= 1\n\n    return dict(message=message, button=button)\n\ndef clear_session():\n    if response.vars and \'session_var\' in response.vars:\n        session_vars = response.vars[\'session_var\']\n    else:\n        session_vars = \'all\'\n    path = paideia_path()\n    path.clear_session(session_vars)\n    print \'clearing session vars: \', session_vars\n    print session\n\n@auth.requires_login()\ndef index():\n    """\n    Main method for presenting various states of the user interface. \n    The states are determined by the first url argument. Processed \n    initially by the view in views/exploring/index.html. The #page \n    region is then refreshed via ajax using the view in views/\n    exploring/index.load\n\n    user must be logged in to access this controller. Otherwise s/he \n    will be redirected to the default login form.\n    """\n\n    print \'====================================================\'\n    print \'new state in controller exploring/index\', datetime.datetime.utcnow()\n    #check to see whether this user session has been initialized\n    if not session.tagset:\n        print \'\\ninitializing new user session\'\n        #categorize paths for today\n        t = tag()\n        session.tagset = t.categorize_tags()\n        print \'stored categorized tags in session.tagset\'\n        #re-activate paths that weren\'t finished during last session\n        p = path()\n        session.active_paths = p.find_unfinished()\n        print \'restored unfinished paths to session.active_paths\'\n\n    #when user begins exploring (also default) present map\n    if (request.args(0) == \'start\') or (not request.args):\n        print \'\\nstart state\'\n        m = map()\n        \'\\n returned to controller exploring/index:\'\n\n        return dict(locs=m.locs, map_image=m.image)\n\n    #after user selects quiz (or \'next question\')\n    elif request.args(0) == \'ask\':\n        print \'\\nask state\'\n        p = path()\n        p_result = p.pick()\n        pid = p_result[\'path\'].id\n        sid = p_result[\'step\']\n        print \'\\nreturned to controller exploring/index:\'\n        print \'path \', pid, \'; step \', sid\n        s = step(sid)\n        return s.ask()\n\n    #after submitting response\n    elif request.args(0) == \'reply\':\n        print \'\\nreply state\'\n        return s.reply()\n\n    #if user response results in an error\n    elif request.args(0) == \'error\':\n        print \'\\nerror state\'\n        return patherror()\n\nresponse._vars=response._caller(index)\n'
p7
sS'snapshot'
p8
(dp9
sS'traceback'
p10
S'Traceback (most recent call last):\n  File "/home/iscott/web/web2py/gluon/restricted.py", line 204, in restricted\n    exec ccode in environment\n  File "/home/iscott/web/web2py/applications/paideia/controllers/exploring.py", line 106, in <module>\n  File "/home/iscott/web/web2py/gluon/globals.py", line 172, in <lambda>\n    self._caller = lambda f: f()\n  File "/home/iscott/web/web2py/gluon/tools.py", line 2533, in f\n    return action(*a, **b)\n  File "/home/iscott/web/web2py/applications/paideia/controllers/exploring.py", line 94, in index\n    return s.ask()\n  File "applications/paideia/modules/paideia_exploring.py", line 388, in ask\n    self.n = self.npc()\n  File "applications/paideia/modules/paideia_exploring.py", line 405, in npc\n    (session.location in db.npcs[n].location)]\n  File "/home/iscott/web/web2py/gluon/dal.py", line 5474, in __getitem__\n    query = self._build_query(key)\n  File "/home/iscott/web/web2py/gluon/dal.py", line 5458, in _build_query\n    if k in self._primarykey:\n  File "/home/iscott/web/web2py/gluon/dal.py", line 5542, in __getattr__\n    return self[key]\n  File "/home/iscott/web/web2py/gluon/dal.py", line 5482, in __getitem__\n    return dict.__getitem__(self, str(key))\nKeyError: \'_primarykey\'\n'
p11
s.